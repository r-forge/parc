\section{paRc---PARallel Computations in R}
\label{sec:paRc}

In the course of this thesis a package called \pkg{paRc}
(\cite{theussl07paRc}) has been developed with the aim
to evaluate performance of parallel applications and to show how
interfacing high performance applications written in C can be done
using OpenMP~(see Section~\ref{sec:OpenMP}).

The package \pkg{paRc} contains interface functions to the OpenMP library
and provides high level function to a few C implementations of
parallel applications using OpenMP (e.g., matrix multiplication---see
Chapter~\ref{chap:matrix}).
Furthermore, it supplies a benchmark environment for performance
evaluation of parallel programs and a framework for pricing options
with parallel Monte Carlo simulation (see
Chapter~\ref{chap:options}).

\pkg{paRc} can be obtained from \url{R-Forge.R-project.org}---the
R-project community service. To install this package directly within R
call \code{install.packages("paRc", repos = "R-Forge.r-project.org")}.
To properly install this package you need either the Intel compiler
with version 9.1 or newer (the Linux compiler is free for
non-commercial use) or the GNU~C compiler with version 4.2 or
newer. They are known to support OpenMP.

Examples in this section are produced on a bignode of
cluster@WU. Bignodes provide a shared memory platform with up to 4
CPUs. Shared memory platforms are necessary for running parallel
OpenMP applications.

\subsection{OpenMP Interface Functions}

The user is provided with a few interface functions to the OpenMP
library. They are used to query the internal variables of the compiled
parallel environment or to change them.

\subsubsection{OpenMP Routines}
\begin{description}
\item[\texttt{omp.get.num.procs()}] returns the number of threads
  available to the program.
\item[\texttt{omp.set.num.threads()}] sets the number of threads to be
  used in subsequent parallel executions.
\item[\texttt{omp.get.max.threads()}] gets the number of threads to be
  used in subsequent parallel executions.
\end{description}

\subsubsection{OpenMP Specific Environment Variables}

Moreover, environment variables can affect the runtime behaviour of
OpenMP programs. These environment variables are~(\cite{openMP05}):

\begin{description}
\item[\texttt{OMP\_NUM\_THREADS}] sets the number of threads to use in
  parallel regions of OpenMP programs. 
\item[\texttt{OMP\_SCHEDULE}] sets the runtime schedule type and
  chunk size.
\item[\texttt{OMP\_DYNAMIC}] defines wether dynamic adjustments of threads
  should be used in parallel regions.
\item[\texttt{OMP\_NESTED}] enables or disables nested parallelism.
\end{description}

Example~\ref{ex:paRcOMP} shows the use of the OpenMP library calls in
R. First the number of available processors is queried. Then the
number of threads a parallel application may use is set to 2. With the
last call the current available CPUs to a parallel program is queried.

\begin{Example} OpenMP function calls using \pkg{paRc}
\label{ex:paRcOMP}
\begin{Schunk}
\begin{Sinput}
> library("paRc")
> omp.get.num.procs()
\end{Sinput}
\begin{Soutput}
[1] 4
\end{Soutput}
\begin{Sinput}
> omp.set.num.threads(2)
> omp.get.max.threads()
\end{Sinput}
\begin{Soutput}
[1] 2
\end{Soutput}
\end{Schunk}
\end{Example}

\subsection{High Level OpenMP Functions}

\pkg{paRc} provides the following high level OpenMP function: 

\begin{description}
\item[\texttt{omp.matrix.mult(X, Y, n\_cpu = 1)}] multiplies the matrix
  \code{X} with matrix \code{Y} using \code{n\_cpu} numbers of
  processors.
\end{description}

\subsection{Benchmark Environment}

\pkg{paRc} provides a benchmark environment for measuring the
performance of parallel programs. Two main functions exist in this
context---one for creating a benchmark object and one for running the
benchmark described by the object.

\subsubsection{Class \class{benchmark}}

An S3 object (\cite{chambers91sms}) named \class{benchmark} contains all
the necessary information to run a benchmark. The list elements are

\begin{description}
\item[task] is a character string defining the task of the
  benchmark. Currently, the 
  following tasks are implemented:
  \begin{itemize}
  \item matrix multiplication
  \item Monte Carlo simulation
  \end{itemize}
\item[data] is a list containing the parameters and data to properly
  run the task
\item[type]defines the parallel programming model used to run the
  benchmark. Currently, the following types are implemented:
  \begin{itemize}
  \item OpenMP---C interface calls provided by \pkg{paRc}
  \item MPI---implementation in \pkg{paRc} using \pkg{Rmpi} for
    communication
  \item PVM---implementation in \pkg{paRc} using \pkg{rpvm} for
    communication 
  \item snow-MPI---implementation in \pkg{snow} using \pkg{Rmpi} for
    communication
  \item snow-PVM---implementation in \pkg{snow} using \pkg{rpvm} for
    communication
  \end{itemize}
\item[cpu\_range] contains a vector of integers representing the number
  of CPUs for th corresponding benchmark run 
\item[is\_parallel] is a logical \code{TRUE} or \code{FALSE} wether the
  contains parallel tasks or not
\end{description}

\subsubsection{Main Routines}

These are the main routines for benchmarking parallel applications:

\begin{description}
\item[\code{create.benchmark(task, data, type, cpu\_range, ...)}]
  defines a benchmark object using a specific \code{task} and the
  corresponding \code{data}. The \code{type} refers to the serial or
  parallel paradigm to use. The \code{cpu\_range} specifies the range
  of CPUs to use for this benchmark. 
\item[\code{run.benchmark(x)}] takes a benchmark object as argument
  and carries out the defined benchmark. It returns an object of type
  bm\_results (which inherits from a dataframe) containing the
  results of the benchmark.
\end{description}


\subsubsection{Extractor and Replacement Functions}

The following routines are for handling a benchmark object. They
extract or replace the values in the benchmark \code{x}.

\begin{itemize}
\item \code{bm.task(x)}
\item \code{bm.data(x)}
\item \code{bm.type(x)}
\item \code{bm.cpu.range(x)}
\end{itemize}

The following routines supply extra information about the benchmark object
or the benchmark environment.

\begin{description}
\item[\code{bm.is.parallel}] returns \code{TRUE} if the benchmark
  contains a parallel function. 
\item[\code{bm.tasks}] returns the tasks which are possible to run
  with the benchmark environment.
\item[\code{bm.types}] returns the types of available serial or
  parallel paradigms to run with the benchmark environment.
\end{description}

\subsubsection{Generic Functions}

Generic functions provide methods for different objects. In \pkg{paRc}
a generic function for calculating the speedup is provided:

\begin{description}
\item[\code{speedup(x)}] is a generic function taking an object as
  arguments. Currently there are two methods implemented namely
  \code{speedup.numeric} and \code{speedup.bm\_results}. The methods
  calculate the speedup as it is presented in
  Equation~\ref{eq:speedup}.
\end{description}

\subsubsection{S3 Methods}

The following S3 methods are provided for the benchmark environment:

\begin{description}
\item[\code{print.benchmark}] prints objects of class \class{benchmark}
\item[\code{plot.bm\_results}] supplies a plot method for comparing
  benchmark results.
\item[\code{speedup.default}] returns an error message that there is
  no default method. 
\item[\code{speedup.numeric}] returns the speedups calculated from a
  vector of type \class{numeric}. The reference execution time is  the
  first element in the vector. The return value is a vector of type
  \class{numeric}. 
\item[\code{speedup.bm\_results}] calculates the speedups from an object
  of class \class{bm\_results} and returns them as a vector of type
  \class{numeric}. 
\end{description}

\subsubsection{Example}

\begin{Example} Running a benchmark using OpenMP
\label{ex:benchrun}
