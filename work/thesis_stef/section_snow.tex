\subsection{The snow package}
\label{sec:snow}
The aim of simple network of workstations (snow --
\cite{rossini03snow}, \cite{tierney07snow}) is to provide a simple
parallel computing environment in R. To make up a virtual cluster in R
snow is based on three different message-passing environments.

\begin{itemize}
\item PVM via R package rpvm (see section \ref{sec:rpvm})
\item MPI via R package Rmpi (see section \ref{sec:Rmpi})
\item SOCK via TCP sockets
\end{itemize}

When using snow one can rely on a good handful of high-level
functions. Indeed snow uses existing interfaces to R and solely
provides one new possibilty of message-passing namely TCP sockets. 

\subsubsection{Initializing and process spawning}

Initializing a snow cluster is rather easy if the system is prepared
accordingly. When using MPI (achieved through Rmpi) a LAM/MPI
environment has to be booted prior starting the virtual cluster (see
section \ref{sec:Rmpi}). Is PVM the method of choice the rpvm package
must be available and an appropriate PVM has to be started (see
section \ref{sec:rpvm}). For both MPI and PVM the parallel environment
can be configured through a grid engine (see appendix
\ref{app:gridengine}). TCP sockets can be set up directly with the
package. When using either MPI or PVM status queries to the
corresponding environment can be made using the functions supplied
from the packages mentioned above.


snow management functions:

\begin{description}
\item[\texttt{makecluster(spec, type = getClusterOption(``type''))}]
  starts a cluster of type \texttt{type} with \texttt{spec} numbers of
  slaves. If the cluster is of connection type SOCK then \texttt{spec}
  must be a charactor vector containing the hostnames of the
  slavenodes to join the cluster. The return value is a list
  containing the cluster specifications. It is necessary in further
  function calls.
\item[\texttt{stopCluster(cl)}] stops a cluster \texttt{cl}.
\end{description}


\textbf{Example:} Start/stop cluster in snow \newline
running on cluster@WU using the node.q -- the parallel environment was
started with the SGE using 8 nodes.

\begin{Schunk}
\begin{Sinput}
> library("snow")
> set.seed(1782)
> n <- 8
> cl <- makeCluster(n, type = "MPI")
\end{Sinput}
\begin{Soutput}
	8 slaves are spawned successfully. 0 failed.
\end{Soutput}
\begin{Sinput}
> stopCluster(cl)
\end{Sinput}
\begin{Soutput}
[1] 1
\end{Soutput}
\end{Schunk}


\subsubsection{Built-in high-level functions}

snow provides a good handful of high-level functions: 


%% TODO
\begin{description}
\item[\texttt{clusterEvalQ(cl, expr)}] evaluates an R expression
  \texttt{expr} on
  each cluster node provided by \texttt{cl}. 
\item[\texttt{clusterCall(cl, fun, ...)}] calls a function
  \texttt{fun} with arguments \ldots on each node found in \texttt{cl}
  and returns a list of the results.
\item[\texttt{clusterApply(cl, x, fun, ...)}] applies a function
  \texttt{fun} with additional arguments \ldots to a specific part of
  a vector \texttt{x}. The return value is of type list with the same
  length as of \texttt{x}. The length of
  \texttt{x} must not exceed the 
  number of R slaves spawned as each element of the vector is used
  exactly by one slave. To achieve some sort of load balancing please
  use the corresponding apply functions below.
\item[\texttt{clusterApplyLB(cl, x, fun, ...)}] is a load balncing
  version of \texttt{clusterApply()} which applies a function
  \texttt{fun} with additional arguments \ldots to a specific part of
  a vector \texttt{x} with the difference that the length of
  \texttt{x} can exceed the number of cluster nodes. If a node
  finished with the computation the next job is placed on the
  available node. This is repeated until all jobs have completed.
\item[\texttt{clusterExport(cl, list)}] broadcasts a list of global
  variables on the master (\texttt{list}) to all slaves.
\item[\texttt{parApply(cl, x, fun, ...)}] is one of the parallel
  versions of the \texttt{apply} functions available in R. I refer to
  the package documentation (\cite{tierney07snow}) for further details.
\item[\texttt{parMM(cl, A,B)}] is a simple parallel implementation of
  matrix multiplication. 
\end{description}


\textbf{Example:} Using high-level functions of snow\newline
running on cluster@WU using the node.q -- the parallel environment was
started with SGE using 8 nodes

\begin{Schunk}
\begin{Sinput}
> n <- 8
> cl <- makeCluster(n, type = "MPI")
\end{Sinput}
\begin{Soutput}
	8 slaves are spawned successfully. 0 failed.
\end{Soutput}
\begin{Sinput}
> x <- rep(n, n)
> rows <- clusterApply(cl, x, runif)
> X <- matrix(unlist(rows), ncol = n, byrow = TRUE)
> X
\end{Sinput}
\begin{Soutput}
          [,1]    [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
[1,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[2,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[3,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[4,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[5,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[6,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[7,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
[8,] 0.7579264 0.64806 0.2317366 0.7676759 0.7091064 0.6417853 0.5890989
          [,8]
[1,] 0.2661573
[2,] 0.2661573
[3,] 0.2661573
[4,] 0.2661573
[5,] 0.2661573
[6,] 0.2661573
[7,] 0.2661573
[8,] 0.2661573
\end{Soutput}
\end{Schunk}



\subsubsection{conclusion}

%The \texttt{PVM.rapply()} example shown in this section followed the Single Program
%Multiple Data (SPMD) paradigm. Data is splitted into different parts
%which are sent to different processes. I/O is handled by a master
%process. When loading rpvm in an R session this session becomes the
%master process. Slaves can easily be spawned provided that there are
%working slave scripts available. A major disadvantage is that the rpvm
%package only has two higher-level function. One of them can be used
%for calculations. That means when using this package for HPC one has
%to deal with low-level message-passing which in turn provides high
%flexibility. New parallel functions can be constructed on the basis of
%the provided interface.

For further interface functions supplied by the snow package, a more detailed
description and further examples please consult the package description
\cite{tierney07snow}.
