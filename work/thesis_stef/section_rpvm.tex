\section{The rpvm Package}
\label{sec:rpvm}
Parallel virtual machine uses the message passing model and makes a
collection of computers appear as a single virtual machine (see Section
\ref{sec:PVM} for details).
The package \pkg{rpvm} (\cite{nali07rpvm}) provides an interface to
low level PVM functions and
a few high level parallel functions to R. It uses most of the
facilities provided by the PVM system which makes \pkg{rpvm} ideal for
prototyping parallel statistical applications in R. Generally, parallel
applications can be either written in compiled languages like C or
FORTRAN or can be called as R processes. The latter method is used in
this thesis and therefore a good selection of \pkg{rpvm}
functions are explained in this section to show how PVM and R can be
used together.

Provided functions are categorized as follows:

\begin{itemize}
\item Initialization and Status Queries
\item Process Spawning and Communication
\item Built-in High Level Functions
\item Other Important Functions
\end{itemize}  

\subsection{Initialization and Status Queries}

At first for using the PVM system \textit{pvmd3} has to be
booted. This can be done via the command line using the \code{pvm}
command (see pages 22 and 23 in \cite{geist94pvm}) or directly within
R after loading the \pkg{rpvm} package using \code{.PVM.start.pvmd()}
explained in this section.

\pkg{rpvm} functions for managing the virtual machine:

\begin{description}
\item[\code{.PVM.start.pvmd()}] boots the \textit{pvmd3} daemon. The
  currently running R session becomes the master process. 
\item[\code{.PVM.add.hosts(hosts)}] takes a vector of hostnames to
  be added to the current virtual machine. The syntax of the
  hostnames is similiar to the lines of a pvmd hostfile (for details
  see the man page of \textit{pvmd3}). 
\item[\code{.PVM.del.hosts()}] simply deletes the given hosts from
  the virtual machine configuration.
\item[\code{.PVM.config()}] returns information about the present
  virtual machine.
\item[\code{.PVM.exit()}] tells the PVM daemon that this process
  leaves the parallel environment.
\item[\code{.PVM.halt()}] shuts down the entire PVM system and exits
  the current R session.
\end{description}
  
When using a job queueing system like he Sun Grid Engine (SGE) to boot
the PVM parallel environment the developer is not engaged with
setting up and booting the environment anymore (see
appendix \ref{app:gridengine} on how to do this).

Example~\ref{ex:rpvm-init} shows how the configuration of the parallel
environment can be obtained. First it returns the hosts connected to
the parallel virtual machine. Finally the
parallel environment is stopped. 

\begin{Example} Query status of PVM \newline
running on cluster@WU using the node.q---the parallel environment was
started with SGE using 8 nodes

\begin{Schunk}
\begin{Sinput}
> library("rpvm")
> set.seed(1782)
> .PVM.config()
\end{Sinput}
\begin{Soutput}
  host.id    name    arch speed
1  262144 node015 LINUX64  1000
2  524288 node003 LINUX64  1000
3  786432 node053 LINUX64  1000
4 1048576 node001 LINUX64  1000
\end{Soutput}
\begin{Sinput}
> .PVM.exit()
\end{Sinput}
\end{Schunk}
\caption{Query status of PVM}
\label{ex:rpvminit}
\end{Example}

\subsection{Process Spawning and Communication}

The package \pkg{rpvm} uses the master-slave paradigm where one
process is the master task and the others are slave tasks. \pkg{rpvm}
provides a routine to spawn R slaves but these slaves cannot be used
interactively like the slaves in \pkg{Rmpi}. The spawned R slaves
source an R script which contains all the necessary function calls to
set up communication and carry out the computation and after
processing terminate.
PVM uses task IDs (tid---a positive integer for identifying a task)
and tags for communication (see
also the fundamentals of message passing in
Section~\ref{sec:messagepassing}).

\begin{description}
\item[\code{.PVM.spawnR(slave, ntask = 1, ...}] spawns \code{ntask}
  copies 
  of an executable or \code{slave} R processes. There are more
  parameters indicated by the \ldots (we refer to
  \cite{nali07rpvm}). The \code{tids} of the successfully spawned R
  slaves are returned.
\item[\code{.PVM.mytid()}] returns the \code{tid} of the calling
  process.
\item[\code{.PVM.parent()}] returns the \code{tid} of the parent
  process that spawned the calling process.
\item[\code{.PVM.siblings()}] returns the \code{tid} of the processes
  that were spawned in a single spawn call.
\end{description}

\subsection{Built-in high level functions}

\pkg{rpvm} provides two high level functions: 

\begin{description}
\item[\code{PVM.rapply(X, FUN = mean, NTASK = 1))}] Apply a function
  \texttt{FUN} to the rows of a matrix \texttt{X} in
  parallel using \texttt{NTASK} tasks.
\item[\code{PVM.options(option, value)}] Get or set values of libpvm
  options (for details see \cite{nali07rpvm} and \cite{geist94pvm}).
\end{description}

\begin{Example} Using PVM.rapply\newline
running on cluster@WU using the node.q -- the parallel environment was
started with SGE using 8 nodes

\begin{Schunk}
\begin{Sinput}
> n <- 8
> X <- matrix(rnorm(n * n), nrow = n)
> round(X, 3)
\end{Sinput}
\begin{Soutput}
       [,1]   [,2]   [,3]   [,4]   [,5]   [,6]   [,7]   [,8]
[1,] -0.200 -0.183  0.560  1.286  0.468  0.502  0.874 -0.778
[2,] -1.371  0.484 -0.498  1.788  0.534 -0.566  0.152 -1.307
[3,]  1.041  0.484  0.399  0.580  0.586 -0.660  1.833 -1.405
[4,] -1.117 -0.893  0.408 -1.612  0.486  0.644  0.422 -1.639
[5,]  1.397 -0.237 -1.287 -0.122 -1.076  0.225 -0.047  0.020
[6,] -0.046  0.537 -1.287 -0.089  0.564  2.671 -0.715 -0.901
[7,]  1.085  0.706 -0.034  0.929  0.057 -2.402 -1.233  1.135
[8,]  0.605 -0.076 -0.554  1.385 -0.436  0.249  0.338  1.369
\end{Soutput}
\begin{Sinput}
> PVM.rapply(X, sum, n)